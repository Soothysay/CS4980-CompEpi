# -*- coding: utf-8 -*-
"""HW3 Q2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wzni-SmyShmwG0edPyZ8_-umd8MZ-Qny

Q 2.1
"""

import pandas as pd
import networkx as nx
filename='facebook.txt'
df_data = pd.read_csv(filename, header=None, delimiter=r"\s+", names=["src", 
"dst"])
print(len(df_data))
# Construct networkx graph object
G = nx.from_pandas_edgelist(df_data, "src", "dst")
    
print(len(G.edges))

from typing import Dict, List, Optional, Set, Tuple

import numpy as np
import matplotlib.pyplot as plt
import os
from tqdm import tqdm
import copy


def simulate_one_round_SI(
    G: nx.Graph,
    node_compartments: Dict[str, Set[int]],
    beta: float,
    rng: np.random.RandomState = np.random.RandomState(0),
):
    if len(node_compartments["I"]) == 0 or len(node_compartments["S"]) == 0:
        return node_compartments
    s_to_i = []
    for node in node_compartments["I"]:
        for neighbor in set(G.neighbors(node)).intersection(node_compartments["S"]):
            if rng.rand() < beta:
                s_to_i.append(neighbor)
    for node in set(s_to_i):
        node_compartments["S"].remove(node)
        node_compartments["I"].add(node)
    return node_compartments


def simulate_t_steps_SI(
    G: nx.Graph,
    i_frac: float,
    beta: float,
    num_rounds: int,
    seed: Optional[int],
    full_output: bool = False):
    rng = np.random.RandomState(seed) if seed is not None else np.random.RandomState()

    num_nodes = G.number_of_nodes()
    i_num = int(i_frac * num_nodes)
    s_num = num_nodes - i_num
    nodes_perm = rng.permutation(G.nodes)
    node_compartments = {
        "S": set(nodes_perm[:s_num].tolist()),
        "I": set(nodes_perm[s_num:].tolist()),
    }
    s = [s_num]
    i = [i_num]
    if full_output:
        s_full = [copy.deepcopy(node_compartments["S"])]
        i_full = [copy.deepcopy(node_compartments["I"])]

    for _ in range(num_rounds):
        node_compartments = simulate_one_round_SI(G, node_compartments, beta, rng)
        if full_output:
            s_full.append(copy.deepcopy(node_compartments["S"]))
            i_full.append(copy.deepcopy(node_compartments["I"]))
        s.append(len(node_compartments["S"]))
        i.append(len(node_compartments["I"]))
    ans = {"S": np.array(s), "I": np.array(i)}
    if full_output:
        return ans, s_full, i_full
    return ans

S=[]
I=[]
for i in range(100):
  a=simulate_t_steps_SI(G=G,i_frac=(4/len(G.nodes)),beta=0.005,num_rounds=100,full_output=False,seed=None)
  S1=a['S'].tolist()
  S2=a['I'].tolist()
  if len(S)==0:
    S=S1
    I=S2
  else:
    for j in range(len(S1)):
      S[j]=S[j]+S1[j]
      I[j]=I[j]+S2[j]
for i in range(len(S)):
  S[i]=S[i]/100
  I[i]=I[i]/100

daily_inf=[]
for i in range(1,(len(I)-1)):
  daily_inf.append(I[i]-I[i-1])

daily_inf.index(max(daily_inf))

fig, ax = plt.subplots()
#ax.plot(range(len(S)),S,label='S',color='blue')
ax.plot(range(len(daily_inf)),daily_inf,label='Daily I',color='red')
ax.legend(loc = 'upper right')
plt.xlabel("Time",fontweight="bold")
plt.ylabel("Number",fontweight="bold")
plt.savefig('SI_daily1.png')

for i in range(len(S)):
  S[i]=S[i]/len(G.nodes)
  I[i]=I[i]/len(G.nodes)

import matplotlib.pyplot as plt
fig, ax = plt.subplots()
ax.plot(range(len(S)),S,label='S',color='blue')
ax.plot(range(len(I)),I,label='I',color='red')
ax.legend(loc = 'upper right')
plt.xlabel("Time",fontweight="bold")
plt.ylabel("Number",fontweight="bold")
plt.savefig('SI1.png')

"""Q 2.2"""

sensor_cand=np.load('/content/rand_nodes.npy')

"""Random"""

sensors1=np.random.choice(sensor_cand,size=500,replace=False)
sensors=sensors1.tolist()
for i in range(len(sensors)):
  sensors[i]=int(sensors[i])

def simulate_t_steps_SI_random(
    G: nx.Graph,
    i_frac: float,
    beta: float,
    num_rounds: int,
    seed: Optional[int],
    sensor_cand:list):
    rng = np.random.RandomState(seed) if seed is not None else np.random.RandomState()
    I=[]
    num_nodes = G.number_of_nodes()
    i_num = int(i_frac * num_nodes)
    s_num = num_nodes - i_num
    nodes_perm = rng.permutation(G.nodes)
    node_compartments = {
        "S": set(nodes_perm[:s_num].tolist()),
        "I": set(nodes_perm[s_num:].tolist()),
    }
    s = [s_num]
    i = [i_num]
    

    for _ in range(num_rounds):
        node_compartments = simulate_one_round_SI(G, node_compartments, beta, rng)
        I_thing=node_compartments['I']
        I.append(sum(x in I_thing for x in sensor_cand))
    return I

I=[]
for i in range(20):
  S2=simulate_t_steps_SI_random(G=G,i_frac=(4/len(G.nodes)),beta=0.005,num_rounds=100,seed=None,sensor_cand=sensors)
  #S1=a['S'].tolist()
  #S2=a['I'].tolist()
  if len(I)==0:
    #S=S1
    I=S2
  else:
    for j in range(len(S2)):
      #S[j]=S[j]+S1[j]
      I[j]=I[j]+S2[j]

for i in range(len(I)):
  #S[i]=S[i]/20
  I[i]=I[i]/20

daily_inf=[]
for i in range(1,(len(I)-1)):
  daily_inf.append(I[i]-I[i-1])

daily_inf.index(max(daily_inf))

fig, ax = plt.subplots()
#ax.plot(range(len(S)),S,label='S',color='blue')
ax.plot(range(len(daily_inf)),daily_inf,label='Daily I',color='red')
ax.legend(loc = 'upper right')
plt.xlabel("Time",fontweight="bold")
plt.ylabel("Number",fontweight="bold")
plt.savefig('SI_dailyrandom_500.png')

for i in range(len(I)):
  #S[i]=S[i]/len(G.nodes)
  I[i]=I[i]/500

I # Random

fig, ax = plt.subplots()
#ax.plot(range(len(S)),S,label='S',color='blue')
ax.plot(range(len(I)),I,label='I',color='red')
ax.legend(loc = 'upper right')
plt.xlabel("Time",fontweight="bold")
plt.ylabel("Number",fontweight="bold")
plt.savefig('SI_random_500.png')

"""Friends"""

sensors2=[]
import random 
for i in range(len(sensors)):
  nb=[n for n in G.neighbors(sensors[i])]
  sensors2.append(random.choice(nb))

I=[]
for i in range(20):
  S2=simulate_t_steps_SI_random(G=G,i_frac=(4/len(G.nodes)),beta=0.005,num_rounds=100,seed=None,sensor_cand=sensors2)
  #S1=a['S'].tolist()
  #S2=a['I'].tolist()
  if len(I)==0:
    #S=S1
    I=S2
  else:
    for j in range(len(S2)):
      #S[j]=S[j]+S1[j]
      I[j]=I[j]+S2[j]

for i in range(len(I)):
  #S[i]=S[i]/20
  I[i]=I[i]/20

I #Friends

daily_inf=[]
for i in range(1,(len(I)-1)):
  daily_inf.append(I[i]-I[i-1])

daily_inf.index(max(daily_inf))

fig, ax = plt.subplots()
#ax.plot(range(len(S)),S,label='S',color='blue')
ax.plot(range(len(daily_inf)),daily_inf,label='Daily I',color='red')
ax.legend(loc = 'upper right')
plt.xlabel("Time",fontweight="bold")
plt.ylabel("Number",fontweight="bold")
plt.savefig('SI_dailyfriends_500.png')

for i in range(len(I)):
  #S[i]=S[i]/len(G.nodes)
  I[i]=I[i]/500

fig, ax = plt.subplots()
#ax.plot(range(len(S)),S,label='S',color='blue')
ax.plot(range(len(I)),I,label='I',color='red')
ax.legend(loc = 'upper right')
plt.xlabel("Time",fontweight="bold")
plt.ylabel("Number",fontweight="bold")
plt.savefig('SI_friends_500.png')

"""Central"""

centrality = nx.eigenvector_centrality_numpy(G)

from heapq import nlargest
N = 500
sensors3 = nlargest(N, centrality, key = centrality.get)

I=[]
for i in range(20):
  S2=simulate_t_steps_SI_random(G=G,i_frac=(4/len(G.nodes)),beta=0.005,num_rounds=100,seed=None,sensor_cand=sensors3)
  #S1=a['S'].tolist()
  #S2=a['I'].tolist()
  if len(I)==0:
    #S=S1
    I=S2
  else:
    for j in range(len(S2)):
      #S[j]=S[j]+S1[j]
      I[j]=I[j]+S2[j]

for i in range(len(I)):
  #S[i]=S[i]/20
  I[i]=I[i]/20

I # Center

daily_inf=[]
for i in range(1,(len(I)-1)):
  daily_inf.append(I[i]-I[i-1])

daily_inf.index(max(daily_inf))

fig, ax = plt.subplots()
#ax.plot(range(len(S)),S,label='S',color='blue')
ax.plot(range(len(daily_inf)),daily_inf,label='Daily I',color='red')
ax.legend(loc = 'upper right')
plt.xlabel("Time",fontweight="bold")
plt.ylabel("Number",fontweight="bold")
plt.savefig('SI_dailycentral_500.png')

for i in range(len(I)):
  #S[i]=S[i]/len(G.nodes)
  I[i]=I[i]/500

fig, ax = plt.subplots()
#ax.plot(range(len(S)),S,label='S',color='blue')
ax.plot(range(len(I)),I,label='I',color='red')
ax.legend(loc = 'upper right')
plt.xlabel("Time",fontweight="bold")
plt.ylabel("Number",fontweight="bold")
plt.savefig('SI_center_500.png')